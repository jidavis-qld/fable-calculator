<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fable Recipe Validator</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
         background: #fafafa; color: #1a1a1a; padding: 32px 24px; min-height: 100vh; }
  .page-wrap { max-width: 1200px; margin: 0 auto; }
  h1 { font-size: 22px; color: #2e4214; margin-bottom: 6px; }
  .subtitle { font-size: 13px; color: #6b7a5c; margin-bottom: 0; }

  /* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
  .controls-bar { margin-bottom: 20px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
                  background: #fff; border: 1px solid #dde8d4; border-radius: 10px; padding: 14px 16px; }
  .controls-bar label { font-size: 13px; color: #4a5a3a; font-weight: 500; }
  .controls-bar select { background: #fff; color: #1a1a1a; border: 1px solid #b8ccaa;
                         border-radius: 6px; padding: 6px 10px; font-size: 13px; cursor: pointer; }
  .run-btn { background: #2e4214; color: #cfff8e; border: none; border-radius: 6px;
             padding: 8px 20px; font-size: 13px; font-weight: 700; cursor: pointer; margin-left: auto; }
  .run-btn:hover { background: #3d5a1c; }
  .back-btn { display: inline-flex; align-items: center; gap: 6px; color: #4a5a3a;
              font-size: 13px; font-weight: 500; text-decoration: none;
              border: 1px solid #b8ccaa; border-radius: 6px; padding: 7px 14px; background: #fff; }
  .back-btn:hover { background: #f0f7e8; }

  /* ‚îÄ‚îÄ Format selector tabs ‚îÄ‚îÄ */
  .format-tabs { display: flex; gap: 8px; margin-bottom: 28px; }
  .fmt-tab { padding: 10px 24px; border-radius: 8px; border: 2px solid #b8ccaa;
             background: #fff; color: #4a5a3a; font-size: 14px; font-weight: 600;
             cursor: pointer; transition: all 0.15s; }
  .fmt-tab:hover { background: #f0f7e8; border-color: #5e8a3c; }
  .fmt-tab.active { background: #2e4214; color: #cfff8e; border-color: #2e4214; }

  /* ‚îÄ‚îÄ Constraints ‚îÄ‚îÄ */
  .constraints { display: flex; gap: 10px; flex-wrap: wrap; }
  .check-item { display: flex; align-items: center; gap: 8px; cursor: pointer;
                background: #fff; border: 1px solid #b8ccaa; border-radius: 8px;
                padding: 8px 14px; user-select: none; transition: background 0.15s; }
  .check-item:hover { background: #f0f7e8; }
  .check-item.checked { background: #e8f5d8; border-color: #5e8a3c; }
  .check-box { width: 14px; height: 14px; border: 2px solid #b8ccaa;
               border-radius: 3px; flex-shrink: 0; position: relative; }
  .check-item.checked .check-box { background: #2e4214; border-color: #2e4214; }
  .check-item.checked .check-box::after { content: '‚úì'; position: absolute;
    top: -2px; left: 1px; font-size: 11px; color: #cfff8e; font-weight: 900; }
  .check-text { font-size: 12px; color: #2a2a2a; font-weight: 600; }
  .check-sub  { font-size: 10px; color: #6b7a5c; margin-top: 1px; }

  /* ‚îÄ‚îÄ Price inputs ‚îÄ‚îÄ */
  .price-controls-wrap { background: #fff; border: 1px solid #dde8d4; border-radius: 10px;
                         padding: 14px 16px; margin-bottom: 28px; display: none; }
  .price-controls-wrap p { font-size: 12px; color: #6b7a5c; margin-bottom: 10px; }
  .price-inputs-grid { display: flex; flex-wrap: wrap; gap: 10px; }
  .price-input-group { display: flex; flex-direction: column; gap: 4px; }
  .price-input-group label { font-size: 11px; color: #6b7a5c; font-weight: 500; }
  .price-input-group input { background: #fff; color: #1a1a1a; border: 1px solid #b8ccaa;
    border-radius: 5px; padding: 5px 8px; font-size: 12px; width: 90px; }
  .price-input-group input:focus { outline: none; border-color: #2e4214; }

  .loading { color: #6b7a5c; font-size: 14px; padding: 40px 0; text-align: center; }

  /* ‚îÄ‚îÄ Section headings ‚îÄ‚îÄ */
  .section-block { margin-bottom: 48px; }
  .section-heading { font-size: 20px; font-weight: 700; color: #2e4214;
                     border-bottom: 2px solid #cfff8e; padding-bottom: 10px; margin-bottom: 20px; }
  .section-subhead { font-size: 13px; color: #6b7a5c; margin-top: -14px; margin-bottom: 20px; }

  /* ‚îÄ‚îÄ Unified table ‚îÄ‚îÄ */
  .tbl-wrap { background: #fff; border: 1px solid #dde8d4; border-radius: 12px;
              overflow: hidden; margin-bottom: 0; }
  table { width: 100%; border-collapse: collapse; font-size: 14px; margin-bottom: 0; }
  th { background: #2e4214; color: #ffffff; font-weight: 600;
       font-size: 15px; padding: 10px 14px; text-align: left; white-space: nowrap; }
  td { padding: 9px 14px; border-bottom: 1px solid #e8ede3; vertical-align: middle;
       color: #2a2a2a; font-weight: 400; white-space: nowrap; }
  tr:last-child td { border-bottom: none; }
  tr:not(.winner-row):hover td { background: #f5f9f0; }

  /* ‚îÄ‚îÄ Winner row ‚Äî zoomed-in feel via scale contrast, no hard borders ‚îÄ‚îÄ */
  .winner-row td { background: #f4fae9; padding-top: 20px; padding-bottom: 20px;
                   font-size: 16px; border-bottom: 1px solid #dff0c0; }
  .winner-row td:first-child { border-left: 3px solid #7db84a; }
  .rec-badge { display: inline-block; background: #2e4214; color: #cfff8e;
               font-size: 10px; font-weight: 700; padding: 2px 8px;
               border-radius: 100px; letter-spacing: 0.05em; vertical-align: middle; margin-left: 8px; }
  .winner-recipe-name { font-weight: 700; font-size: 16px; }
  .winner-trim-name { font-size: 12px; color: #6b7a5c; margin-top: 2px; }
  td.col-recipe { white-space: normal; min-width: 160px; }

  /* ‚îÄ‚îÄ Delta badges ‚îÄ‚îÄ */
  .delta { display: inline-block; font-size: 12px; border-radius: 100px;
           padding: 2px 9px; font-weight: 600; white-space: nowrap; }
  .delta-worse  { background: #fef2f2; color: #991b1b; border: 1px solid #fca5a5; }
  .delta-better { background: #e8f5d8; color: #166534; border: 1px solid #86efac; }
  .delta-neutral{ background: #f3f4f6; color: #4b5563; border: 1px solid #d1d5db; }

  /* ‚îÄ‚îÄ UK Traffic Light Label (validator comparison) ‚îÄ‚îÄ */
  .tfl-comparison { display: flex; gap: 28px; align-items: flex-end; flex-wrap: wrap; margin-top: 24px; }
  .tfl-col { display: flex; flex-direction: column; gap: 6px; }
  .tfl-col-label { font-size: 11px; font-weight: 700; letter-spacing: 0.1em;
                   text-transform: uppercase; color: #4a5a3a; }
  .tfl-label { display: inline-flex; border: 2px solid #1a1a1a; border-radius: 4px;
               overflow: hidden; font-family: Arial, Helvetica, sans-serif; }
  .tfl-per100 { background: #1a1a1a; color: #fff; display: flex; flex-direction: column;
                align-items: center; justify-content: center; padding: 10px;
                font-size: 10px; font-weight: 700; text-align: center; line-height: 1.3;
                min-width: 46px; letter-spacing: 0.02em; text-transform: uppercase; }
  .tfl-nutrients { display: flex; }
  .tfl-cell { display: flex; flex-direction: column; align-items: center;
              justify-content: flex-end; padding: 8px 10px; min-width: 72px;
              border-left: 1px solid #1a1a1a; }
  .tfl-cell-inner { display: flex; flex-direction: column; align-items: center; width: 100%; }
  .tfl-pill { width: 100%; border-radius: 3px; padding: 6px 4px 5px; text-align: center;
              margin-bottom: 6px; display: flex; flex-direction: column; align-items: center;
              justify-content: center; min-height: 42px; }
  .tfl-pill.green  { background: #008000; color: #fff; }
  .tfl-pill.amber  { background: #ffc000; color: #1a1a1a; }
  .tfl-pill.red    { background: #cc0000; color: #fff; }
  .tfl-pill.dark   { background: #1a1a1a; color: #fff; }
  .tfl-traffic-word { font-size: 11px; font-weight: 700; text-transform: uppercase;
                      letter-spacing: 0.04em; line-height: 1; }
  .tfl-value { font-size: 15px; font-weight: 900; line-height: 1.1; margin-top: 3px; }
  .tfl-unit { font-size: 9px; font-weight: 400; margin-top: 1px; opacity: 0.85; }
  .tfl-nutrient-name { font-size: 10px; font-weight: 700; text-align: center;
                       color: #1a1a1a; line-height: 1.2; margin-bottom: 2px; }
  .tfl-ri { font-size: 9px; color: #555; text-align: center; line-height: 1.2; }
  .tfl-ri-note { font-size: 10px; color: #6b7a5c; margin-top: 6px; }
  .tfl-section-heading { font-size: 11px; font-weight: 700; letter-spacing: 0.12em;
                         text-transform: uppercase; color: #4a5a3a; margin-bottom: 10px;
                         margin-top: 28px; }

  /* ‚îÄ‚îÄ Claim tiles ‚îÄ‚îÄ */
  .claim-tiles { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 16px; }
  .claim-tile { display: inline-flex; align-items: center; gap: 7px;
                background: #e8f5d8; color: #1a3d0a; border: 1.5px solid #7db84a;
                border-radius: 8px; padding: 8px 14px; font-size: 13px; font-weight: 700; }
  .claim-tile-icon { font-size: 15px; line-height: 1; }
  .claim-tile-label { font-size: 12px; font-weight: 400; color: #4a5a3a; margin-top: 1px; }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  .tbl-wrap { overflow-x: auto; -webkit-overflow-scrolling: touch; }

  @media (max-width: 640px) {
    body { padding: 16px 14px; }
    h1 { font-size: 18px; }
    .controls-bar { gap: 8px; padding: 12px; }
    .controls-bar label { font-size: 12px; }
    .controls-bar select { font-size: 12px; padding: 5px 8px; }
    .run-btn { margin-left: 0; width: 100%; text-align: center; padding: 10px; }
    .constraints { width: 100%; }
    .format-tabs { flex-wrap: wrap; }
    .fmt-tab { padding: 8px 16px; font-size: 13px; }
    .section-heading { font-size: 17px; }
    .section-subhead { font-size: 12px; }
    table { font-size: 13px; }
    th { font-size: 13px; padding: 9px 10px; }
    td { padding: 8px 10px; }
    .winner-row td { padding-top: 14px; padding-bottom: 14px; font-size: 14px; }
    .winner-recipe-name { font-size: 14px; }
    .delta { font-size: 11px; padding: 1px 7px; }
  }
</style>
</head>
<body>
<div class="page-wrap">

<div style="display:flex; align-items:center; gap:16px; margin-bottom:24px;">
  <a href="index.html" class="back-btn">‚Üê Back to Calculator</a>
  <div>
    <h1>Recipe Validator</h1>
    <p class="subtitle">Select a format, trim and country to see recommendations and how alternatives compare.</p>
  </div>
</div>

<div class="controls-bar">
  <label>Country:</label>
  <select id="country-select" onchange="runValidator()">
    <option value="US">üá∫üá∏ United States</option>
    <option value="UK">üá¨üáß United Kingdom</option>
    <option value="AU">üá¶üá∫ Australia</option>
    <option value="EU">üá™üá∫ Europe</option>
  </select>
  <label>Q1 beef trim:</label>
  <select id="q1-select">
    <option value="0.1">90CL ‚Äî 10% fat</option>
    <option value="0.15">85CL ‚Äî 15% fat</option>
    <option value="0.2" selected>80CL ‚Äî 20% fat</option>
    <option value="0.25">75CL ‚Äî 25% fat</option>
  </select>
  <div class="constraints">
    <div class="check-item" id="check-fiber" onclick="toggleConstraint('fiber')">
      <div class="check-box"></div>
      <div>
        <div class="check-text">Must be High in Fiber</div>
        <div class="check-sub" id="fiber-sub">‚â•5g fiber per 100g</div>
      </div>
    </div>
    <div id="fiber-note" style="display:none; font-size:11px; color:#6b7a5c; align-self:center;"></div>
    <div class="check-item" id="check-protein" onclick="toggleConstraint('protein')">
      <div class="check-box"></div>
      <div>
        <div class="check-text">Must be High in Protein</div>
        <div class="check-sub" id="protein-sub">‚â•10g protein per 100g</div>
      </div>
    </div>
  </div>
  <button class="run-btn" onclick="runValidator()">Run</button>
</div>

<div class="format-tabs" id="format-tabs"></div>

<div class="price-controls-wrap" id="price-controls">
  <p>Adjust beef prices to test sensitivity. Rankings update live as you type.</p>
  <div class="price-inputs-grid" id="price-inputs"></div>
</div>

<div id="output"><p class="loading">Loading data‚Ä¶</p></div>

</div><!-- /.page-wrap -->
<script>
/* ‚îÄ‚îÄ Supabase config ‚îÄ‚îÄ */
const SUPABASE_URL = 'https://qrtomlulbcuantmtaxfc.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFydG9tbHVsYmN1YW50bXRheGZjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE1MTU3MDgsImV4cCI6MjA4NzA5MTcwOH0.hcA0SYB5DEPGjxTdvfbKroixsFbJ83Syi_F9BCn7B9k';

const COUNTRY_CONFIG = {
  US: {
    code: 'US',
    currency: '$', priceUnit: 'per lb',
    fablePrice: 4.98, waterPrice: 0.001,
    highFiber: 5, sourceFiber: 2.5,
    highProtein: { mode: 'grams', g: 10 }, sourceProtein: { mode: 'grams', g: 5 },
    fiberSpelling: 'Fiber',
  },
  UK: {
    code: 'UK',
    currency: '¬£', priceUnit: 'per kg',
    fablePrice: 6.00, waterPrice: 0.001,
    highFiber: 6, sourceFiber: 3,
    highProtein: { mode: 'energyPct', pct: 20 }, sourceProtein: { mode: 'energyPct', pct: 10 },
    fiberSpelling: 'Fibre',
  },
  AU: {
    code: 'AU',
    currency: '$', priceUnit: 'per kg',
    fablePrice: 7.50, waterPrice: 0.001,
    highFiber: 7, sourceFiber: 4,
    highProtein: { mode: 'grams', g: 10 }, sourceProtein: { mode: 'grams', g: 5 },
    fiberSpelling: 'Fibre',
  },
  EU: {
    code: 'EU',
    currency: '‚Ç¨', priceUnit: 'per kg',
    fablePrice: 6.50, waterPrice: 0.001,
    highFiber: 6, sourceFiber: 3,
    highProtein: { mode: 'energyPct', pct: 20 }, sourceProtein: { mode: 'energyPct', pct: 10 },
    fiberSpelling: 'Fibre',
  },
};
let CC = COUNTRY_CONFIG.US;

async function sbFetch(table, params = '') {
  const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?select=*${params ? '&' + params : ''}`, {
    headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
  });
  return res.json();
}

/* ‚îÄ‚îÄ Data stores ‚îÄ‚îÄ */
let BEEF_PRICES = {}, RECIPES = {}, HEALTH_REF = { shiitake: {}, beef: {} };
let SHIITAKE_CO2 = 0, BEEF_CO2 = 0, SCORING_CONFIG = {};
let activeFormat = null;

/* ‚îÄ‚îÄ Constraint state ‚îÄ‚îÄ */
let mustFiber = false, mustProtein = false;

function toggleConstraint(which) {
  if (which === 'fiber') {
    mustFiber = !mustFiber;
    document.getElementById('check-fiber').classList.toggle('checked', mustFiber);
  } else {
    mustProtein = !mustProtein;
    document.getElementById('check-protein').classList.toggle('checked', mustProtein);
  }
}

/* ‚îÄ‚îÄ Hide the fiber constraint when it cannot be achieved ‚îÄ‚îÄ
   AU: threshold (7g) is never reachable ‚Äî hide always.
   UK/EU + Burger/Meatball: water recipes excluded, shiitake % is
   too low at burger ratios ‚Äî hide when that format is active.      */
function updateFiberVisibility() {
  const fiberEl  = document.getElementById('check-fiber');
  const noteEl   = document.getElementById('fiber-note');
  const isBurger = activeFormat === 'Burger / Meatball';
  const hideAU   = CC.code === 'AU';
  const hideBurger = (CC.code === 'UK' || CC.code === 'EU') && isBurger;
  const hide     = hideAU || hideBurger;

  fiberEl.style.display = hide ? 'none' : '';

  if (hideBurger) {
    noteEl.style.display = '';
    noteEl.textContent = 'High in Fibre not available for Burger / Meatball ‚Äî insufficient fibre for a strong bind.';
  } else {
    noteEl.style.display = 'none';
    noteEl.textContent = '';
  }

  if (hide && mustFiber) {
    mustFiber = false;
    fiberEl.classList.remove('checked');
  }
}

const CL_ORDER_LEAN = [
  '60CL Beef Trim','65CL Beef Trim','70CL Beef Trim',
  '75CL Beef Trim','80CL Beef Trim','85CL Beef Trim','90CL Beef Trim'
];

async function loadData() {
  BEEF_PRICES = {}; RECIPES = {}; HEALTH_REF = { shiitake: {}, beef: {} };
  SHIITAKE_CO2 = 0; BEEF_CO2 = 0; SCORING_CONFIG = {};
  const selectedCode = document.getElementById('country-select').value;
  CC = COUNTRY_CONFIG[selectedCode];

  const fiberSub = `‚â•${CC.highFiber}g ${CC.fiberSpelling.toLowerCase()} per 100g`;
  const proteinSub = CC.highProtein.mode === 'energyPct'
    ? `‚â•${CC.highProtein.pct}% energy from protein`
    : `‚â•${CC.highProtein.g}g protein per 100g`;
  document.getElementById('fiber-sub').textContent = fiberSub;
  document.getElementById('protein-sub').textContent = proteinSub;
  document.querySelector('#check-fiber .check-text').textContent = `Must be High in ${CC.fiberSpelling}`;
  updateFiberVisibility();

  const countryFilter = `country=eq.${selectedCode}`;
  const [nutrition, beefPrices, recipes, co2, scoringCfg] = await Promise.all([
    sbFetch('nutrition',   countryFilter),
    sbFetch('beef_prices', countryFilter),
    sbFetch('recipes',     countryFilter),
    sbFetch('co2_kg_e'),
    sbFetch('scoring_config'),
  ]);
  beefPrices.forEach(r => {
    BEEF_PRICES[r.trim] = { fat: parseFloat(r.fat_pct), price: parseFloat(r.price) };
  });
  recipes.forEach(r => {
    if (!RECIPES[r.format]) RECIPES[r.format] = {};
    RECIPES[r.format][r.recipe] = [parseFloat(r.beef_pct), parseFloat(r.fable_pct), parseFloat(r.water_pct)];
  });
  nutrition.forEach(r => {
    if (r.ingredient === 'shiitake') {
      HEALTH_REF.shiitake[r.nutrient] = { val: parseFloat(r.value) };
    } else {
      if (!HEALTH_REF.beef[r.ingredient]) HEALTH_REF.beef[r.ingredient] = {};
      HEALTH_REF.beef[r.ingredient][r.nutrient] = parseFloat(r.value);
    }
  });
  co2.forEach(r => {
    if (r.ingredient === 'shiitake') SHIITAKE_CO2 = parseFloat(r.co2_per_kg);
    if (r.ingredient === 'beef')     BEEF_CO2     = parseFloat(r.co2_per_kg);
  });
  scoringCfg.forEach(r => { SCORING_CONFIG[r.key] = parseFloat(r.value); });
}

function getBlendNutrient(nutrient, recipeName, trimName, format) {
  const [beefPct, fablePct] = RECIPES[format][recipeName];
  const s = HEALTH_REF.shiitake[nutrient]?.val ?? 0;
  const b = HEALTH_REF.beef[trimName]?.[nutrient] ?? 0;
  return s * fablePct + b * beefPct;
}

function getWeightSets() {
  const cfg = SCORING_CONFIG;
  return {
    balance:        { n: cfg.balance_n        ?? 0.66, c: cfg.balance_c        ?? 0.34, s: cfg.balance_s        ?? 0.00 },
    cost:           { n: cfg.cost_n           ?? 0.00, c: cfg.cost_c           ?? 1.00, s: cfg.cost_s           ?? 0.00 },
    nutrition:      { n: cfg.nutrition_n      ?? 1.00, c: cfg.nutrition_c      ?? 0.15, s: cfg.nutrition_s      ?? 0.10 },
    sustainability: { n: cfg.sustainability_n ?? 0.15, c: cfg.sustainability_c ?? 0.10, s: cfg.sustainability_s ?? 1.00 },
  };
}

function meetsHighProtein(protein_g, energyKJ) {
  const cfg = CC.highProtein;
  if (cfg.mode === 'energyPct') {
    if (!energyKJ || energyKJ === 0) return false;
    return (protein_g * 17 / energyKJ * 100) >= cfg.pct;
  }
  return protein_g >= cfg.g;
}

/* ‚îÄ‚îÄ Scoring engine ‚îÄ‚îÄ */
function scoringEngine(format, priority, userFat) {
  const shiitakeFat   = (HEALTH_REF.shiitake['Total Fat']?.val ?? 0) / 100;
  const shiitakeFiber = (HEALTH_REF.shiitake['Dietary Fiber'] ?? HEALTH_REF.shiitake['Dietary Fibre'])?.val ?? 0;
  const userTrimName  = Object.entries(BEEF_PRICES).find(([, d]) => d.fat === userFat)?.[0];
  const ceilIdx       = CL_ORDER_LEAN.indexOf(userTrimName);

  function naturalTrimIdx(beefPct, fablePct) {
    let floorIdx = null;
    for (let i = 0; i < CL_ORDER_LEAN.length; i++) {
      const data = BEEF_PRICES[CL_ORDER_LEAN[i]];
      if (!data) continue;
      if ((data.fat * beefPct) + (shiitakeFat * fablePct) > userFat + 0.02) floorIdx = i;
    }
    if (floorIdx !== null) return floorIdx;
    for (let i = 0; i < CL_ORDER_LEAN.length; i++) {
      const data = BEEF_PRICES[CL_ORDER_LEAN[i]];
      if (!data) continue;
      if ((data.fat * beefPct) + (shiitakeFat * fablePct) <= userFat) return i;
    }
    return CL_ORDER_LEAN.length - 1;
  }

  function buildCandidates(applyConstraints) {
    const out = [];
    for (const [recipeName, [beefPct, fablePct, waterPct]] of Object.entries(RECIPES[format])) {
      if (format === 'Burger / Meatball' && waterPct > 0) continue;
      if (format === 'Burger / Meatball' && beefPct === 0.5) continue;
      if (format !== 'Burger / Meatball' && waterPct === 0) continue;
      const floorIdx = naturalTrimIdx(beefPct, fablePct);
      const lo = Math.min(floorIdx, ceilIdx), hi = Math.max(floorIdx, ceilIdx);
      for (let i = lo; i <= hi; i++) {
        const trimName = CL_ORDER_LEAN[i];
        const trimData = BEEF_PRICES[trimName];
        if (!trimData) continue;
        const fiber    = shiitakeFiber * fablePct;
        const protein  = getBlendNutrient('Protein',           recipeName, trimName, format);
        const energyKJ = getBlendNutrient('Energy (kJ)', recipeName, trimName, format);
        const cals     = CC.code === 'AU'
          ? energyKJ / 4.184
          : getBlendNutrient('Energy (Calories)', recipeName, trimName, format);
        const satFat   = getBlendNutrient('Saturated Fat',     recipeName, trimName, format);
        const cost     = beefPct * trimData.price + fablePct * CC.fablePrice + waterPct * CC.waterPrice;
        const co2      = beefPct * BEEF_CO2 + fablePct * SHIITAKE_CO2;
        const blendedFat = (trimData.fat * beefPct) + (shiitakeFat * fablePct);
        if (applyConstraints) {
          if (mustFiber   && fiber < CC.highFiber)                continue;
          if (mustProtein && !meetsHighProtein(protein, energyKJ)) continue;
        }
        out.push({ recipeName, trimName, beefPct, fablePct, waterPct,
                   fiber, protein, energyKJ, cals, satFat, cost, co2, blendedFat });
      }
    }
    return out;
  }

  const constrained = buildCandidates(true);
  const pool        = constrained.length > 0 ? constrained : buildCandidates(false);
  if (pool.length === 0) return [];

  function normalise(values, lowerBetter) {
    const min = Math.min(...values), max = Math.max(...values);
    if (max === min) return values.map(() => 1.0);
    return values.map(v => lowerBetter ? (max - v) / (max - min) : (v - min) / (max - min));
  }
  const cfg     = SCORING_CONFIG;
  const nFiber   = normalise(pool.map(c => c.fiber),   false);
  const nProtein = normalise(pool.map(c => c.protein), false);
  const nCals    = normalise(pool.map(c => c.cals),    true);
  const nSatFat  = normalise(pool.map(c => c.satFat),  true);
  const nCost    = normalise(pool.map(c => c.cost),    true);
  const nCO2     = normalise(pool.map(c => c.co2),     true);

  const nutritionScore = pool.map((_, i) =>
    (cfg.nutr_w_fiber    ?? 0.35) * nFiber[i] +
    (cfg.nutr_w_protein  ?? 0.35) * nProtein[i] +
    (cfg.nutr_w_calories ?? 0.20) * nCals[i] +
    (cfg.nutr_w_satfat   ?? 0.10) * nSatFat[i]
  );

  const WEIGHT_SETS  = getWeightSets();
  const w            = WEIGHT_SETS[priority] || WEIGHT_SETS.balance;
  const trimPenalty  = cfg.trim_penalty ?? 0.05;
  const userCeilIdx  = ceilIdx;

  const finalScores = pool.map((c, i) => {
    const raw = w.n * nutritionScore[i] + w.c * nCost[i] + w.s * nCO2[i];
    const candidateIdx = CL_ORDER_LEAN.indexOf(c.trimName);
    const stepsLeaner  = Math.max(0, userCeilIdx - candidateIdx);
    return (priority === 'balance') ? raw * (1 - trimPenalty * stepsLeaner) : raw;
  });

  return pool
    .map((c, i) => ({ ...c, nutritionScore: nutritionScore[i], finalScore: finalScores[i] }))
    .sort((a, b) => b.finalScore - a.finalScore);
}

/* ‚îÄ‚îÄ Price persistence helpers ‚îÄ‚îÄ */
function priceStorageKey(country) { return `beef_prices_${country}`; }

function savePricesToStorage(country) {
  const saved = {};
  Object.entries(BEEF_PRICES).forEach(([k, v]) => { saved[k] = v.price; });
  localStorage.setItem(priceStorageKey(country), JSON.stringify(saved));
}

function loadPricesFromStorage(country) {
  try {
    const raw = localStorage.getItem(priceStorageKey(country));
    if (!raw) return null;
    return JSON.parse(raw);
  } catch { return null; }
}

function applyStoredPrices(country) {
  const stored = loadPricesFromStorage(country);
  if (!stored) return;
  Object.entries(stored).forEach(([trimName, price]) => {
    if (BEEF_PRICES[trimName]) BEEF_PRICES[trimName].price = price;
  });
}

/* ‚îÄ‚îÄ Price inputs ‚îÄ‚îÄ */
function buildPriceInputs() {
  const wrap = document.getElementById('price-inputs');
  wrap.innerHTML = '';

  // Apply any previously-saved prices for this country
  applyStoredPrices(CC.code);

  CL_ORDER_LEAN.slice().reverse().forEach(trimName => {
    const data = BEEF_PRICES[trimName];
    if (!data) return;
    const cl  = trimName.replace(' Beef Trim', '');
    const div = document.createElement('div');
    div.className = 'price-input-group';
    div.innerHTML = `<label>${cl} (${CC.currency}/${CC.priceUnit.replace('per ', '')})</label>
      <input type="number" step="0.01" min="0" value="${data.price.toFixed(2)}"
        data-trimname="${trimName}">`;
    wrap.appendChild(div);
  });

  // Attach live listeners after building
  wrap.querySelectorAll('input').forEach(input => {
    input.addEventListener('input', () => {
      const trimName = input.dataset.trimname;
      const val = parseFloat(input.value);
      if (!isNaN(val) && val >= 0) {
        BEEF_PRICES[trimName].price = val;
        savePricesToStorage(CC.code);
        renderOutput();
      }
    });
  });

  document.getElementById('price-controls').style.display = 'block';
}

/* ‚îÄ‚îÄ Format tabs ‚îÄ‚îÄ */
function buildFormatTabs(formats) {
  const wrap = document.getElementById('format-tabs');
  wrap.innerHTML = '';
  formats.forEach((fmt, i) => {
    const btn = document.createElement('button');
    btn.className = 'fmt-tab' + (i === 0 ? ' active' : '');
    btn.textContent = fmt;
    btn.onclick = () => {
      document.querySelectorAll('.fmt-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      activeFormat = fmt;
      updateFiberVisibility();
      renderOutput();
    };
    wrap.appendChild(btn);
  });
}

/* ‚îÄ‚îÄ Delta badge helper ‚îÄ‚îÄ */
function deltaBadge(diff, unit, lowerBetter, zeroLabel = null) {
  if (Math.abs(diff) < 0.005) return zeroLabel
    ? `<span class="delta delta-neutral">${zeroLabel}</span>`
    : `<span class="delta delta-neutral">same</span>`;
  const better = lowerBetter ? diff < 0 : diff > 0;
  const cls    = better ? 'delta-better' : 'delta-worse';
  const sign   = diff > 0 ? '+' : '‚àí';
  return `<span class="delta ${cls}">${sign}${unit}${Math.abs(diff).toFixed(2)}</span>`;
}
function deltaBadgeInt(diff, unit, lowerBetter) {
  if (Math.abs(diff) < 0.5) return `<span class="delta delta-neutral">same</span>`;
  const better = lowerBetter ? diff < 0 : diff > 0;
  const cls    = better ? 'delta-better' : 'delta-worse';
  const sign   = diff > 0 ? '+' : '‚àí';
  return `<span class="delta ${cls}">${sign}${Math.abs(Math.round(diff))} ${unit}</span>`;
}

/* ‚îÄ‚îÄ Generic ranked table ‚Äî winner is first row, max 4 rows total ‚îÄ‚îÄ */
function renderRankedTable(ranked, recBadgeLabel, colDefs) {
  // Always cap at 4 total rows (winner + 3 alternatives)
  const rows = ranked.slice(0, 4);
  if (rows.length === 0) return '<p style="color:#6b7a5c">No candidates available.</p>';
  const winner = rows[0];

  let html = `<div class="tbl-wrap"><table><thead><tr><th style="width:36px;text-align:center;">#</th>`;
  colDefs.forEach(col => { html += `<th>${col.header}</th>`; });
  html += `</tr></thead><tbody>`;

  rows.forEach((c, idx) => {
    const isWinner = idx === 0;
    const rankCell = isWinner
      ? `<td style="text-align:center;font-weight:700;color:#2e4214;">‚òÖ</td>`
      : `<td style="text-align:center;color:#6b7a5c;font-size:13px;">${idx + 1}</td>`;
    html += `<tr${isWinner ? ' class="winner-row"' : ''}>${rankCell}`;
    colDefs.forEach(col => {
      const cls = col.className ? ` class="${col.className}"` : '';
      html += `<td${cls}>${col.cell(c, winner, isWinner)}</td>`;
    });
    html += `</tr>`;
  });

  html += `</tbody></table></div>`;
  return html;
}

/* ‚îÄ‚îÄ Recipe name cell for winner vs alternative ‚îÄ‚îÄ */
function recipeCell(c, winner, isWinner, badgeLabel) {
  if (isWinner) {
    return `<div class="winner-recipe-name">${c.recipeName}
              <span class="rec-badge">${badgeLabel}</span></div>`;
  }
  return c.recipeName;
}

/* ‚îÄ‚îÄ UK Traffic Light helpers ‚îÄ‚îÄ */
const TFL_THRESHOLDS = {
  fat:       { green: 3,    amber: 17.5, unit: 'g',  name: 'Fat',       ri: 70 },
  saturates: { green: 1.5,  amber: 5,    unit: 'g',  name: 'Saturates', ri: 20 },
  sugars:    { green: 5,    amber: 22.5, unit: 'g',  name: 'Sugars',    ri: 90 },
  salt:      { green: 0.3,  amber: 1.5,  unit: 'g',  name: 'Salt',      ri: 6  },
};
const ENERGY_RI_KJ = 8400;

function tflColour(val, green, amber) {
  return val <= green ? 'green' : val <= amber ? 'amber' : 'red';
}

function buildTflLabelHtml(energyKJ, energyKcal, fat, saturates, sugars, salt) {
  const energyRiPct = Math.round((energyKJ / ENERGY_RI_KJ) * 100);
  const nutrients = [
    { key: 'fat',       val: fat,       fmt: fat.toFixed(1)       },
    { key: 'saturates', val: saturates, fmt: saturates.toFixed(1) },
    { key: 'sugars',    val: sugars,    fmt: sugars.toFixed(1)     },
    { key: 'salt',      val: salt,      fmt: salt.toFixed(2)       },
  ];
  const cellsHtml = nutrients.map(({ key, val, fmt }) => {
    const t      = TFL_THRESHOLDS[key];
    const colour = tflColour(val, t.green, t.amber);
    const riPct  = Math.round((val / t.ri) * 100);
    return `<div class="tfl-cell">
      <div class="tfl-cell-inner">
        <div class="tfl-pill ${colour}">
          <span class="tfl-traffic-word">${colour.charAt(0).toUpperCase() + colour.slice(1)}</span>
          <span class="tfl-value">${fmt}</span>
          <span class="tfl-unit">${t.unit}</span>
        </div>
        <div class="tfl-nutrient-name">${t.name}</div>
        <div class="tfl-ri">${riPct}% RI*</div>
      </div>
    </div>`;
  }).join('');

  return `<div class="tfl-label">
    <div class="tfl-per100">per<br>100g</div>
    <div class="tfl-nutrients">
      <div class="tfl-cell" style="min-width:80px; border-left:1px solid #1a1a1a;">
        <div class="tfl-cell-inner">
          <div class="tfl-pill dark">
            <span class="tfl-value" style="font-size:13px;">${Math.round(energyKJ)}</span>
            <span class="tfl-unit">kJ</span>
            <span class="tfl-value" style="font-size:11px; margin-top:2px;">${Math.round(energyKcal)}</span>
            <span class="tfl-unit">kcal</span>
          </div>
          <div class="tfl-nutrient-name">Energy</div>
          <div class="tfl-ri">${energyRiPct}% RI*</div>
        </div>
      </div>
      ${cellsHtml}
    </div>
  </div>`;
}

function renderTflComparison(winner, format) {
  if (CC.code !== 'UK') return '';

  const rn = winner.recipeName, tn = winner.trimName;

  // Blend values
  const bEnergyKJ  = getBlendNutrient('Energy (kJ)',       rn, tn, format);
  const bEnergyKcal= getBlendNutrient('Energy (Calories)', rn, tn, format);
  const bFat       = getBlendNutrient('Total Fat',         rn, tn, format);
  const bSaturates = getBlendNutrient('Saturated Fat',     rn, tn, format);
  const bSugars    = getBlendNutrient('Total Sugars',      rn, tn, format);
  const bSalt      = getBlendNutrient('Salt',              rn, tn, format);

  // 100% beef reference (same trim)
  const beefRef    = HEALTH_REF.beef[tn] ?? {};
  const rEnergyKJ  = beefRef['Energy (kJ)']       ?? 0;
  const rEnergyKcal= beefRef['Energy (Calories)'] ?? 0;
  const rFat       = beefRef['Total Fat']          ?? 0;
  const rSaturates = beefRef['Saturated Fat']      ?? 0;
  const rSugars    = beefRef['Total Sugars']       ?? 0;
  const rSalt      = beefRef['Salt']               ?? (beefRef['Sodium'] ? beefRef['Sodium'] / 400 : 0);

  const blendLabel = buildTflLabelHtml(bEnergyKJ, bEnergyKcal, bFat, bSaturates, bSugars, bSalt);
  const beefLabel  = buildTflLabelHtml(rEnergyKJ, rEnergyKcal, rFat, rSaturates, rSugars, rSalt);
  const beefColHdr = '100% ' + tn.replace(' Beef Trim', '') + ' Beef Trim';

  return `
    <div class="tfl-section-heading">UK Traffic Light ‚Äî per 100g</div>
    <div class="tfl-comparison">
      <div class="tfl-col">
        <div class="tfl-col-label">${winner.recipeName}</div>
        ${blendLabel}
      </div>
      <div class="tfl-col">
        <div class="tfl-col-label">${beefColHdr}</div>
        ${beefLabel}
      </div>
    </div>
    <p class="tfl-ri-note">*RI = Reference Intake for an average adult (8,400 kJ / 2,000 kcal)</p>`;
}

/* ‚îÄ‚îÄ Claim tiles ‚Äî shown beneath each section's winner when claims are met ‚îÄ‚îÄ */
function renderClaimTiles(winner) {
  const tiles = [];

  // High in Fibre ‚Äî country-aware threshold
  if (winner.fiber >= CC.highFiber) {
    tiles.push(`<div class="claim-tile">
      <span class="claim-tile-icon">üåø</span>
      <div>
        <div>High in ${CC.fiberSpelling}</div>
        <div class="claim-tile-label">‚â•${CC.highFiber}g per 100g</div>
      </div>
    </div>`);
  }

  // High in Protein ‚Äî uses the same country-aware check as the scoring engine
  if (meetsHighProtein(winner.protein, winner.energyKJ)) {
    const sub = CC.highProtein.mode === 'energyPct'
      ? `‚â•${CC.highProtein.pct}% energy from protein`
      : `‚â•${CC.highProtein.g}g per 100g`;
    tiles.push(`<div class="claim-tile">
      <span class="claim-tile-icon">üí™</span>
      <div>
        <div>High in Protein</div>
        <div class="claim-tile-label">${sub}</div>
      </div>
    </div>`);
  }

  if (tiles.length === 0) return '';
  return `<div class="claim-tiles">${tiles.join('')}</div>`;
}

/* ‚îÄ‚îÄ Render balance section ‚îÄ‚îÄ */
function renderBalanceSection(format, userFat) {
  const ranked = scoringEngine(format, 'balance', userFat);
  if (ranked.length === 0) return '<p style="color:#6b7a5c">No candidates available.</p>';
  const winner = ranked[0];
  const priceUnit = CC.priceUnit.split(' ')[1];

  const cols = [
    { header: 'Recipe', className: 'col-recipe',
      cell: (c, w, iw) => recipeCell(c, w, iw, '‚òÖ Recommended') },
    { header: 'Beef Trim',
      cell: (c) => c.trimName.replace(' Beef Trim', '') },
    { header: `${CC.currency}/${priceUnit}`,
      cell: (c, w, iw) => iw
        ? `${CC.currency}${c.cost.toFixed(2)}`
        : `${CC.currency}${c.cost.toFixed(2)} ${deltaBadge(c.cost - w.cost, CC.currency, true)}` },
    { header: `${CC.fiberSpelling} (g/100g)`,
      cell: (c, w, iw) => iw
        ? c.fiber.toFixed(1)
        : `${c.fiber.toFixed(1)} ${deltaBadge(c.fiber - w.fiber, '', false)}` },
    { header: 'Protein (g/100g)',
      cell: (c, w, iw) => iw
        ? c.protein.toFixed(1)
        : `${c.protein.toFixed(1)} ${deltaBadge(c.protein - w.protein, '', false)}` },
    { header: 'Calories',
      cell: (c, w, iw) => iw
        ? c.cals.toFixed(0)
        : `${c.cals.toFixed(0)} ${deltaBadgeInt(c.cals - w.cals, 'kcal', true)}` },
    { header: 'Sat Fat (g)',
      cell: (c, w, iw) => iw
        ? c.satFat.toFixed(1)
        : `${c.satFat.toFixed(1)} ${deltaBadge(c.satFat - w.satFat, '', true)}` },
  ];

  return renderRankedTable(ranked, '‚òÖ Recommended', cols)
       + renderTflComparison(winner, format);
}

/* ‚îÄ‚îÄ Render cost section ‚îÄ‚îÄ */
function renderCostSection(format, userFat) {
  const all = scoringEngine(format, 'cost', userFat);
  if (all.length === 0) return '<p style="color:#6b7a5c">No candidates available.</p>';
  const ranked = [...all].sort((a, b) => a.cost - b.cost);
  const priceUnit = CC.priceUnit.split(' ')[1];

  const cols = [
    { header: 'Recipe', className: 'col-recipe',
      cell: (c, w, iw) => recipeCell(c, w, iw, '$ Lowest Cost') },
    { header: 'Beef Trim',
      cell: (c) => c.trimName.replace(' Beef Trim', '') },
    { header: `${CC.currency}/${priceUnit}`,
      cell: (c, w, iw) => {
        if (iw) return `${CC.currency}${c.cost.toFixed(2)}`;
        const diff = c.cost - w.cost;
        return `${CC.currency}${c.cost.toFixed(2)} <span class="delta delta-worse">+${CC.currency}${diff.toFixed(2)}</span>`;
      }},
    { header: `${CC.fiberSpelling} (g/100g)`,
      cell: (c) => c.fiber.toFixed(1) },
    { header: 'Protein (g/100g)',
      cell: (c) => c.protein.toFixed(1) },
    { header: 'Calories',
      cell: (c) => c.cals.toFixed(0) },
    { header: 'Sat Fat (g)',
      cell: (c) => c.satFat.toFixed(1) },
  ];

  return renderRankedTable(ranked, '$ Lowest Cost', cols);
}

/* ‚îÄ‚îÄ Render nutrition section ‚îÄ‚îÄ */
function renderNutritionSection(format, userFat) {
  const all = scoringEngine(format, 'nutrition', userFat);
  if (all.length === 0) return '<p style="color:#6b7a5c">No candidates available.</p>';
  // Already sorted by finalScore (nutrition-weighted) ‚Äî just use that order
  const ranked = all;
  const winner = ranked[0];
  const priceUnit = CC.priceUnit.split(' ')[1];

  const cols = [
    { header: 'Recipe', className: 'col-recipe',
      cell: (c, w, iw) => recipeCell(c, w, iw, '‚ú¶ Best Nutrition') },
    { header: 'Beef Trim',
      cell: (c) => c.trimName.replace(' Beef Trim', '') },
    { header: `${CC.fiberSpelling} (g/100g)`,
      cell: (c, w, iw) => iw
        ? c.fiber.toFixed(1)
        : `${c.fiber.toFixed(1)} ${deltaBadge(c.fiber - w.fiber, '', false)}` },
    { header: 'Protein (g/100g)',
      cell: (c, w, iw) => iw
        ? c.protein.toFixed(1)
        : `${c.protein.toFixed(1)} ${deltaBadge(c.protein - w.protein, '', false)}` },
    { header: 'Calories',
      cell: (c, w, iw) => iw
        ? c.cals.toFixed(0)
        : `${c.cals.toFixed(0)} ${deltaBadgeInt(c.cals - w.cals, 'kcal', true)}` },
    { header: 'Sat Fat (g)',
      cell: (c, w, iw) => iw
        ? c.satFat.toFixed(1)
        : `${c.satFat.toFixed(1)} ${deltaBadge(c.satFat - w.satFat, '', true)}` },
    { header: `${CC.currency}/${priceUnit}`,
      cell: (c, w, iw) => iw
        ? `${CC.currency}${c.cost.toFixed(2)}`
        : `${CC.currency}${c.cost.toFixed(2)} ${deltaBadge(c.cost - w.cost, CC.currency, true)}` },
  ];

  return renderRankedTable(ranked, '‚ú¶ Best Nutrition', cols);
}

/* ‚îÄ‚îÄ Main render ‚îÄ‚îÄ */
function renderOutput() {
  const userFat = parseFloat(document.getElementById('q1-select').value);
  const format  = activeFormat;

  let html = '';

  // Section 1: Balanced
  html += `<div class="section-block">
    <div class="section-heading">Balanced recommendation</div>
    <p class="section-subhead">The best overall recipe weighing both cost and nutrition. Alternatives shown with differences against each metric.</p>
    ${renderBalanceSection(format, userFat)}
  </div>`;

  // Section 2: Cost
  html += `<div class="section-block">
    <div class="section-heading">Cost ranking</div>
    <p class="section-subhead">Recipes ranked from lowest to highest cost, with nutrition stats for comparison.</p>
    ${renderCostSection(format, userFat)}
  </div>`;

  // Section 3: Nutrition
  html += `<div class="section-block">
    <div class="section-heading">Nutrition ranking</div>
    <p class="section-subhead">Recipes ranked by best nutritional profile ‚Äî highest ${CC.fiberSpelling.toLowerCase()}, protein, lower calories and saturated fat.</p>
    ${renderNutritionSection(format, userFat)}
  </div>`;

  document.getElementById('output').innerHTML = html;
}

/* ‚îÄ‚îÄ Entry point ‚îÄ‚îÄ */
let _lastCountry = null;

async function runValidator() {
  const selectedCode = document.getElementById('country-select').value;
  const countryChanged = selectedCode !== _lastCountry;

  // If country changed, clear saved prices so fresh DB prices load
  if (countryChanged && _lastCountry !== null) {
    localStorage.removeItem(priceStorageKey(selectedCode));
  }
  _lastCountry = selectedCode;

  document.getElementById('output').innerHTML = '<p class="loading">Running‚Ä¶</p>';
  document.getElementById('format-tabs').innerHTML = '';
  await loadData();
  buildPriceInputs();

  const formats = Object.keys(RECIPES);
  activeFormat  = activeFormat && formats.includes(activeFormat) ? activeFormat : formats[0];
  buildFormatTabs(formats);
  updateFiberVisibility();
  renderOutput();
}

window.addEventListener('DOMContentLoaded', () => {
  _lastCountry = document.getElementById('country-select').value;
  runValidator();
});
</script>
</body>
</html>
