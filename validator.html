<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fable Recipe Validator</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
         background: #fafafa; color: #1a1a1a; padding: 32px; min-height: 100vh; }
  h1 { font-size: 22px; color: #2e4214; margin-bottom: 6px; }
  .subtitle { font-size: 13px; color: #6b7a5c; margin-bottom: 32px; }

  .format-block { margin-bottom: 48px; }
  .format-title { font-size: 16px; font-weight: 700; color: #2e4214;
                  border-bottom: 2px solid #cfff8e;
                  padding-bottom: 8px; margin-bottom: 16px; }

  table { width: 100%; border-collapse: collapse; font-size: 13px; margin-bottom: 24px; }
  th { background: #2e4214; color: #cfff8e; font-weight: 600;
       padding: 9px 12px; text-align: left; white-space: nowrap; }
  td { padding: 9px 12px; border-bottom: 1px solid #e8ede3; vertical-align: middle; color: #2a2a2a; }
  tr:hover td { background: #f5f9f0; }

  .winner-row td { background: #f0f7e8; }
  .fallback-badge { display: inline-block; background: #fff3cd; color: #856404;
                    font-size: 10px; font-weight: 700; padding: 2px 7px;
                    border-radius: 100px; margin-left: 6px; border: 1px solid #ffc107; }

  .summary-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px,1fr));
                  gap: 12px; margin-bottom: 32px; }
  .summary-card { background: #fff; border: 1px solid #dde8d4;
                  border-radius: 10px; padding: 14px 16px; }
  .summary-card .label { font-size: 11px; color: #6b7a5c; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.04em; }
  .summary-card .value { font-size: 20px; font-weight: 700; color: #2e4214; }

  .controls-bar { margin-bottom: 20px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
                  background: #fff; border: 1px solid #dde8d4; border-radius: 10px; padding: 14px 16px; }
  .controls-bar label { font-size: 13px; color: #4a5a3a; font-weight: 500; }
  .controls-bar select { background: #fff; color: #1a1a1a;
                         border: 1px solid #b8ccaa; border-radius: 6px;
                         padding: 6px 10px; font-size: 13px; cursor: pointer; }
  .run-btn { background: #2e4214; color: #cfff8e; border: none; border-radius: 6px;
             padding: 8px 20px; font-size: 13px; font-weight: 700; cursor: pointer; margin-left: auto; }
  .run-btn:hover { background: #3d5a1c; }
  .back-btn { display: inline-flex; align-items: center; gap: 6px; color: #4a5a3a;
              font-size: 13px; font-weight: 500; text-decoration: none;
              border: 1px solid #b8ccaa; border-radius: 6px; padding: 7px 14px;
              background: #fff; }
  .back-btn:hover { background: #f0f7e8; }

  .constraints { display: flex; gap: 10px; flex-wrap: wrap; }
  .check-item { display: flex; align-items: center; gap: 8px; cursor: pointer;
                background: #fff; border: 1px solid #b8ccaa;
                border-radius: 8px; padding: 8px 14px; user-select: none;
                transition: background 0.15s; }
  .check-item:hover { background: #f0f7e8; }
  .check-item.checked { background: #e8f5d8; border-color: #5e8a3c; }
  .check-box { width: 14px; height: 14px; border: 2px solid #b8ccaa;
               border-radius: 3px; flex-shrink: 0; position: relative; }
  .check-item.checked .check-box { background: #2e4214; border-color: #2e4214; }
  .check-item.checked .check-box::after { content: '‚úì'; position: absolute;
    top: -2px; left: 1px; font-size: 11px; color: #cfff8e; font-weight: 900; }
  .check-text { font-size: 12px; color: #2a2a2a; font-weight: 600; }
  .check-sub  { font-size: 10px; color: #6b7a5c; margin-top: 1px; }

  .price-controls-wrap { background: #fff; border: 1px solid #dde8d4; border-radius: 10px;
                         padding: 14px 16px; margin-bottom: 28px; display: none; }
  .price-controls-wrap p { font-size: 12px; color: #6b7a5c; margin-bottom: 10px; }
  .price-inputs-grid { display: flex; flex-wrap: wrap; gap: 10px; }
  .price-input-group { display:flex; flex-direction:column; gap:4px; }
  .price-input-group label { font-size:11px; color:#6b7a5c; font-weight: 500; }
  .price-input-group input { background: #fff; color: #1a1a1a;
    border: 1px solid #b8ccaa; border-radius: 5px;
    padding: 5px 8px; font-size: 12px; width: 90px; }
  .price-input-group input:focus { outline: none; border-color: #2e4214; }

  .loading { color: #6b7a5c; font-size: 14px; padding: 40px 0; text-align: center; }

  .priority-chip { display:inline-block; padding:3px 10px; border-radius:100px;
    font-size:11px; font-weight:700; }
  .pc-cost       { background: #fef9e7; color: #856404; border: 1px solid #fde68a; }
  .pc-nutrition  { background: #e8f5d8; color: #2e4214; border: 1px solid #cfff8e; }
  .pc-balance    { background: #ede9f6; color: #5b21b6; border: 1px solid #c4b5fd; }
  .pc-sustain    { background: #ecfdf5; color: #065f46; border: 1px solid #6ee7b7; }

  .runner-up-cell { font-size: 12px; color: #4a5a3a; line-height: 1.7; }
  .runner-up-name { font-weight: 600; color: #1a1a1a; }
  .ru-delta { display: inline-block; font-size: 11px; border-radius: 100px;
              padding: 1px 7px; font-weight: 600; }
  .ru-worse { background: #fef2f2; color: #991b1b; border: 1px solid #fca5a5; }
  .ru-better { background: #e8f5d8; color: #166534; border: 1px solid #86efac; }

  .nutrient-val { font-weight: 600; }
  .flag-red { color: #b91c1c; }
</style>
</head>
<body>

<div style="display:flex; align-items:center; gap:16px; margin-bottom:24px;">
  <a href="index.html" class="back-btn">‚Üê Back to Calculator</a>
  <div>
    <h1>Recipe Validator</h1>
    <p class="subtitle">Tests all priorities and formats through the scoring engine. Adjust prices to see how results shift.</p>
  </div>
</div>

<div class="controls-bar">
  <label>Country:</label>
  <select id="country-select">
    <option value="US">üá∫üá∏ United States</option>
    <option value="UK">üá¨üáß United Kingdom</option>
  </select>
  <label>Q1 beef trim:</label>
  <select id="q1-select">
    <option value="0.1">90CL ‚Äî 10% fat</option>
    <option value="0.15">85CL ‚Äî 15% fat</option>
    <option value="0.2" selected>80CL ‚Äî 20% fat</option>
    <option value="0.25">75CL ‚Äî 25% fat</option>
  </select>
  <div class="constraints">
    <div class="check-item" id="check-fiber" onclick="toggleConstraint('fiber')">
      <div class="check-box"></div>
      <div>
        <div class="check-text">Must be High in Fiber</div>
        <div class="check-sub" id="fiber-sub">‚â•5g fiber per 100g</div>
      </div>
    </div>
    <div class="check-item" id="check-protein" onclick="toggleConstraint('protein')">
      <div class="check-box"></div>
      <div>
        <div class="check-text">Must be High in Protein</div>
        <div class="check-sub" id="protein-sub">‚â•10g protein per 100g</div>
      </div>
    </div>
  </div>
  <button class="run-btn" onclick="runValidator()">Run</button>
</div>

<div class="price-controls-wrap" id="price-controls">
  <p>Adjust beef prices to test sensitivity. Changes apply on next run.</p>
  <div class="price-inputs-grid" id="price-inputs"></div>
</div>

<div id="output"><p class="loading">Loading data‚Ä¶</p></div>

<script>
/* ‚îÄ‚îÄ Supabase config ‚îÄ‚îÄ */
const SUPABASE_URL = 'https://qrtomlulbcuantmtaxfc.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFydG9tbHVsYmN1YW50bXRheGZjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE1MTU3MDgsImV4cCI6MjA4NzA5MTcwOH0.hcA0SYB5DEPGjxTdvfbKroixsFbJ83Syi_F9BCn7B9k';
const COUNTRY_CONFIG = {
  US: {
    currency: '$', priceUnit: 'per lb',
    fablePrice: 4.98, waterPrice: 0.001,
    highFiber: 5, sourceFiber: 2.5,
    highProtein: { mode: 'grams', g: 10 }, sourceProtein: { mode: 'grams', g: 5 },
    fiberSpelling: 'Fiber',
  },
  UK: {
    currency: '¬£', priceUnit: 'per kg',
    fablePrice: 6.00, waterPrice: 0.001,
    highFiber: 6, sourceFiber: 3,
    highProtein: { mode: 'energyPct', pct: 20 }, sourceProtein: { mode: 'energyPct', pct: 10 },
    fiberSpelling: 'Fibre',
  },
};
let CC = COUNTRY_CONFIG.US;

async function sbFetch(table, params = '') {
  const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?select=*${params ? '&' + params : ''}`, {
    headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
  });
  return res.json();
}

/* ‚îÄ‚îÄ Data stores ‚îÄ‚îÄ */
let BEEF_PRICES = {}, RECIPES = {}, HEALTH_REF = { shiitake: {}, beef: {} };
let SHIITAKE_CO2 = 0, BEEF_CO2 = 0;
let SCORING_CONFIG = {};

/* ‚îÄ‚îÄ Constraint state ‚îÄ‚îÄ */
let mustFiber   = false;
let mustProtein = false;

function toggleConstraint(which) {
  if (which === 'fiber') {
    mustFiber = !mustFiber;
    document.getElementById('check-fiber').classList.toggle('checked', mustFiber);
  } else {
    mustProtein = !mustProtein;
    document.getElementById('check-protein').classList.toggle('checked', mustProtein);
  }
}

const CL_ORDER_LEAN = [
  '60CL Beef Trim','65CL Beef Trim','70CL Beef Trim',
  '75CL Beef Trim','80CL Beef Trim','85CL Beef Trim','90CL Beef Trim'
];

async function loadData() {
  BEEF_PRICES = {}; RECIPES = {}; HEALTH_REF = { shiitake: {}, beef: {} };
  SHIITAKE_CO2 = 0; BEEF_CO2 = 0; SCORING_CONFIG = {};
  const selectedCountry = document.getElementById('country-select').value;
  CC = COUNTRY_CONFIG[selectedCountry];
  // Update constraint sub-labels to match country
  const fiberSub = CC.highProtein.mode === 'energyPct'
    ? `‚â•${CC.highFiber}g ${CC.fiberSpelling.toLowerCase()} per 100g`
    : `‚â•${CC.highFiber}g ${CC.fiberSpelling.toLowerCase()} per 100g`;
  const proteinSub = CC.highProtein.mode === 'energyPct'
    ? `‚â•${CC.highProtein.pct}% energy from protein`
    : `‚â•${CC.highProtein.g}g protein per 100g`;
  document.getElementById('fiber-sub').textContent = fiberSub;
  document.getElementById('protein-sub').textContent = proteinSub;
  document.querySelector('#check-fiber .check-text').textContent = `Must be High in ${CC.fiberSpelling}`;

  const countryFilter = `country=eq.${selectedCountry}`;
  const [nutrition, beefPrices, recipes, co2, scoringCfg] = await Promise.all([
    sbFetch('nutrition',   countryFilter),
    sbFetch('beef_prices', countryFilter),
    sbFetch('recipes',     countryFilter),
    sbFetch('co2_kg_e'),
    sbFetch('scoring_config'),
  ]);
  beefPrices.forEach(r => {
    BEEF_PRICES[r.trim] = { fat: parseFloat(r.fat_pct), price: parseFloat(r.price) };
  });
  recipes.forEach(r => {
    if (!RECIPES[r.format]) RECIPES[r.format] = {};
    RECIPES[r.format][r.recipe] = [parseFloat(r.beef_pct), parseFloat(r.fable_pct), parseFloat(r.water_pct)];
  });
  nutrition.forEach(r => {
    if (r.ingredient === 'shiitake') {
      HEALTH_REF.shiitake[r.nutrient] = { val: parseFloat(r.value) };
    } else {
      if (!HEALTH_REF.beef[r.ingredient]) HEALTH_REF.beef[r.ingredient] = {};
      HEALTH_REF.beef[r.ingredient][r.nutrient] = parseFloat(r.value);
    }
  });
  co2.forEach(r => {
    if (r.ingredient === 'shiitake') SHIITAKE_CO2 = parseFloat(r.co2_per_kg);
    if (r.ingredient === 'beef')     BEEF_CO2     = parseFloat(r.co2_per_kg);
  });
  scoringCfg.forEach(r => { SCORING_CONFIG[r.key] = parseFloat(r.value); });
}

function getBlendNutrient(nutrient, recipeName, trimName, format) {
  const [beefPct, fablePct] = RECIPES[format][recipeName];
  const s = HEALTH_REF.shiitake[nutrient]?.val ?? 0;
  const b = HEALTH_REF.beef[trimName]?.[nutrient] ?? 0;
  return s * fablePct + b * beefPct;
}

/* ‚îÄ‚îÄ Weight sets ‚îÄ‚îÄ */
function getWeightSets() {
  const cfg = SCORING_CONFIG;
  return {
    cost:           { n: cfg.cost_n           ?? 0.00, c: cfg.cost_c           ?? 1.00, s: cfg.cost_s           ?? 0.00 },
    nutrition:      { n: cfg.nutrition_n      ?? 1.00, c: cfg.nutrition_c      ?? 0.15, s: cfg.nutrition_s      ?? 0.10 },
    balance:        { n: cfg.balance_n        ?? 0.50, c: cfg.balance_c        ?? 0.50, s: cfg.balance_s        ?? 0.00 },
    sustainability: { n: cfg.sustainability_n ?? 0.15, c: cfg.sustainability_c ?? 0.10, s: cfg.sustainability_s ?? 1.00 },
  };
}

const PRIORITY_LABELS = {
  cost:           { label: 'Lower Cost',       cls: 'pc-cost'      },
  nutrition:      { label: 'Better Nutrition', cls: 'pc-nutrition' },
  balance:        { label: 'Balance',          cls: 'pc-balance'   },
  sustainability: { label: 'Sustainability',   cls: 'pc-sustain'   },
};

function meetsHighProtein(protein_g, energyKJ) {
  const cfg = CC.highProtein;
  if (cfg.mode === 'energyPct') {
    if (!energyKJ || energyKJ === 0) return false;
    return (protein_g * 17 / energyKJ * 100) >= cfg.pct;
  }
  return protein_g >= cfg.g;
}

/* ‚îÄ‚îÄ Scoring engine (mirrors index.html exactly) ‚îÄ‚îÄ */
function scoringEngine(format, priority, userFat) {
  const shiitakeFat   = (HEALTH_REF.shiitake['Total Fat']?.val   ?? 0) / 100;
  const shiitakeFiber = HEALTH_REF.shiitake['Dietary Fiber']?.val ?? 0;

  const userTrimName = Object.entries(BEEF_PRICES).find(([, d]) => d.fat === userFat)?.[0];
  const ceilIdx = CL_ORDER_LEAN.indexOf(userTrimName);

  function naturalTrimIdx(beefPct, fablePct) {
    let floorIdx = null;
    for (let i = 0; i < CL_ORDER_LEAN.length; i++) {
      const data = BEEF_PRICES[CL_ORDER_LEAN[i]];
      if (!data) continue;
      const blendedFat = (data.fat * beefPct) + (shiitakeFat * fablePct);
      if (blendedFat > userFat) floorIdx = i;
    }
    if (floorIdx !== null) return floorIdx;
    for (let i = 0; i < CL_ORDER_LEAN.length; i++) {
      const data = BEEF_PRICES[CL_ORDER_LEAN[i]];
      if (!data) continue;
      if ((data.fat * beefPct) + (shiitakeFat * fablePct) <= userFat) return i;
    }
    return CL_ORDER_LEAN.length - 1;
  }

  function buildCandidates(applyConstraints) {
    const out = [];
    for (const [recipeName, [beefPct, fablePct, waterPct]] of Object.entries(RECIPES[format])) {
      if (format === 'Burger / Meatball' && waterPct > 0) continue;
      if (format === 'Burger / Meatball' && beefPct === 0.5) continue;
      const floorIdx = naturalTrimIdx(beefPct, fablePct);
      const lo = Math.min(floorIdx, ceilIdx);
      const hi = Math.max(floorIdx, ceilIdx);
      for (let i = lo; i <= hi; i++) {
        const trimName = CL_ORDER_LEAN[i];
        const trimData = BEEF_PRICES[trimName];
        if (!trimData) continue;
        const blendedFat = (trimData.fat * beefPct) + (shiitakeFat * fablePct);
        const fiber    = shiitakeFiber * fablePct;
        const protein  = getBlendNutrient('Protein',           recipeName, trimName, format);
        const cals     = getBlendNutrient('Energy (Calories)', recipeName, trimName, format);
        const satFat   = getBlendNutrient('Saturated Fat',     recipeName, trimName, format);
        const cost     = beefPct * trimData.price + fablePct * CC.fablePrice + waterPct * CC.waterPrice;
        const co2      = beefPct * BEEF_CO2 + fablePct * SHIITAKE_CO2;
        const energyKJ = getBlendNutrient('Energy (kJ)', recipeName, trimName, format);
        if (applyConstraints) {
          if (mustFiber   && fiber < CC.highFiber)                continue;
          if (mustProtein && !meetsHighProtein(protein, energyKJ)) continue;
        }
        out.push({ recipeName, trimName, beefPct, fablePct, waterPct,
                   fiber, protein, energyKJ, cals, satFat, cost, co2, blendedFat });
      }
    }
    return out;
  }

  const constrained = buildCandidates(true);
  const usedFallback = constrained.length === 0 && (mustFiber || mustProtein);
  const pool = constrained.length > 0 ? constrained : buildCandidates(false);

  if (pool.length === 0) return [];

  function normalise(values, lowerBetter) {
    const min = Math.min(...values), max = Math.max(...values);
    if (max === min) return values.map(() => 1.0);
    return values.map(v => lowerBetter ? (max - v) / (max - min) : (v - min) / (max - min));
  }
  function normalisePadded(values, lowerBetter, pad) {
    const min = Math.min(...values), max = Math.max(...values);
    const spread = max - min;
    if (spread === 0) return values.map(() => 1.0);
    const lo = min - spread * pad, hi = max + spread * pad;
    return values.map(v => lowerBetter ? (hi - v) / (hi - lo) : (v - lo) / (hi - lo));
  }

  const cfg = SCORING_CONFIG;
  const costPad = cfg.cost_pad ?? 1.5;
  const co2Pad  = cfg.co2_pad  ?? 1.0;

  const nFiber   = normalise(pool.map(c => c.fiber),   false);
  const nProtein = normalise(pool.map(c => c.protein), false);
  const nCals    = normalise(pool.map(c => c.cals),    true);
  const nSatFat  = normalise(pool.map(c => c.satFat),  true);
  const nCost    = normalisePadded(pool.map(c => c.cost), true, costPad);
  const nCO2     = normalisePadded(pool.map(c => c.co2),  true, co2Pad);

  const nutritionRaw = pool.map((_, i) =>
    (cfg.nutr_w_fiber    ?? 0.35) * nFiber[i] +
    (cfg.nutr_w_protein  ?? 0.35) * nProtein[i] +
    (cfg.nutr_w_calories ?? 0.20) * nCals[i] +
    (cfg.nutr_w_satfat   ?? 0.10) * nSatFat[i]
  );
  const nutritionScore = nutritionRaw.map(v => Math.sqrt(v));

  const WEIGHT_SETS = getWeightSets();
  const w = WEIGHT_SETS[priority] || WEIGHT_SETS.balance;

  const trimPenalty = cfg.trim_penalty ?? 0.05;
  const brb         = cfg.balance_recipe_bonus ?? 0.12;

  const finalScores = pool.map((c, i) => {
    const raw = w.n * nutritionScore[i] + w.c * nCost[i] + w.s * nCO2[i];
    const candidateIdx = CL_ORDER_LEAN.indexOf(c.trimName);
    const stepsLeaner  = Math.max(0, ceilIdx - candidateIdx);
    const penalised = (priority === 'balance')
      ? raw * (1 - trimPenalty * stepsLeaner)
      : raw;
    const bonus = (priority === 'balance')
      ? brb * Math.exp(-Math.pow((c.fablePct + c.waterPct) - 0.40, 2) / (2 * 0.10 * 0.10))
      : 0;
    return penalised + bonus;
  });

  return pool
    .map((c, i) => ({
      ...c,
      nutritionScore: nutritionScore[i],
      finalScore: finalScores[i],
      usedFallback,
    }))
    .sort((a, b) => b.finalScore - a.finalScore);
}

/* ‚îÄ‚îÄ Build editable price inputs ‚îÄ‚îÄ */
function buildPriceInputs() {
  const wrap = document.getElementById('price-inputs');
  wrap.innerHTML = '';
  CL_ORDER_LEAN.slice().reverse().forEach(trimName => {
    const data = BEEF_PRICES[trimName];
    if (!data) return;
    const cl = trimName.replace(' Beef Trim','');
    const div = document.createElement('div');
    div.className = 'price-input-group';
    div.innerHTML = `<label>${cl} (${CC.currency}/${CC.priceUnit.replace('per ','')})</label>
      <input type="number" step="0.01" min="0" value="${data.price.toFixed(2)}"
        onchange="BEEF_PRICES['${trimName}'].price = parseFloat(this.value) || ${data.price.toFixed(2)}">`;
    wrap.appendChild(div);
  });
  document.getElementById('price-controls').style.display = 'block';
}

/* ‚îÄ‚îÄ Runner-up comparison HTML ‚îÄ‚îÄ */
function runnerUpHtml(winner, runnerUp, priority) {
  if (!runnerUp) return '<span style="color:#aaa">‚Äî</span>';
  const name = `${runnerUp.recipeName} / ${runnerUp.trimName.replace(' Beef Trim','')}`;

  let deltas = [];

  if (priority === 'cost') {
    // Cost priority: show how much more expensive the runner-up is
    const diff = runnerUp.cost - winner.cost;
    const sign = diff > 0 ? '+' : '';
    const cls = diff > 0 ? 'ru-worse' : 'ru-better';
    deltas.push(`<span class="ru-delta ${cls}">${sign}${CC.currency}${Math.abs(diff).toFixed(2)} cost</span>`);
  } else {
    // Score-based priorities: express runner-up score as % behind winner
    const scoreDiff = winner.finalScore - runnerUp.finalScore;
    const pctBehind = winner.finalScore > 0 ? Math.round(scoreDiff / winner.finalScore * 100) : 0;
    if (pctBehind > 0) {
      deltas.push(`<span class="ru-delta ru-worse">${pctBehind}% lower score</span>`);
    } else {
      deltas.push(`<span class="ru-delta ru-better">tied</span>`);
    }
    // Also show cost difference as context
    const costDiff = runnerUp.cost - winner.cost;
    const sign = costDiff > 0 ? '+' : '';
    const cls = costDiff > 0 ? 'ru-worse' : 'ru-better';
    deltas.push(`<span class="ru-delta ${cls}">${sign}${CC.currency}${Math.abs(costDiff).toFixed(2)} cost</span>`);
  }

  return `<div class="runner-up-cell">
    <span class="runner-up-name">${name}</span><br>
    ${deltas.join(' ')}
  </div>`;
}

/* ‚îÄ‚îÄ Render ‚îÄ‚îÄ */
async function runValidator() {
  document.getElementById('output').innerHTML = '<p class="loading">Running‚Ä¶</p>';
  await loadData();
  buildPriceInputs();

  const userFat = parseFloat(document.getElementById('q1-select').value);
  const userTrimName = Object.entries(BEEF_PRICES).find(([, d]) => d.fat === userFat)?.[0] || '80CL Beef Trim';
  const formats = Object.keys(RECIPES);
  const WEIGHT_SETS = getWeightSets();
  const priorities = Object.keys(WEIGHT_SETS);
  const priceUnit = CC.priceUnit.split(' ')[1];

  let html = '';

  for (const format of formats) {
    html += `<div class="format-block">`;
    html += `<div class="format-title">${format} ‚Äî Q1 trim: ${userTrimName.replace(' Beef Trim','')}</div>`;
    html += `<table>
      <thead><tr>
        <th>Priority</th>
        <th>Recommended Recipe</th>
        <th>Beef Trim</th>
        <th>${CC.fiberSpelling} (g/100g)</th>
        <th>Protein (g/100g)</th>
        <th>Calories</th>
        <th>Sat Fat (g)</th>
        <th>${CC.currency}/${priceUnit}</th>
        <th>Runner-up</th>
      </tr></thead><tbody>`;

    priorities.forEach(priority => {
      const ranked = scoringEngine(format, priority, userFat);
      if (ranked.length === 0) return;

      const winner   = ranked[0];
      const runnerUp = ranked[1];

      const { label, cls } = PRIORITY_LABELS[priority];
      const fallbackHtml = winner.usedFallback
        ? `<span class="fallback-badge">constraint not met</span>`
        : '';

      const fiberFlag = mustFiber && winner.fiber < CC.highFiber ? ' flag-red' : '';
      const proteinFlag = mustProtein && !meetsHighProtein(winner.protein, winner.energyKJ) ? ' flag-red' : '';

      html += `<tr class="winner-row">
        <td><span class="priority-chip ${cls}">${label}</span></td>
        <td><strong>${winner.recipeName}</strong>${fallbackHtml}</td>
        <td>${winner.trimName.replace(' Beef Trim','')}</td>
        <td><span class="nutrient-val${fiberFlag}">${winner.fiber.toFixed(1)}</span></td>
        <td><span class="nutrient-val${proteinFlag}">${winner.protein.toFixed(1)}</span></td>
        <td>${winner.cals.toFixed(0)}</td>
        <td>${winner.satFat.toFixed(1)}</td>
        <td>${CC.currency}${winner.cost.toFixed(2)}</td>
        <td>${runnerUpHtml(winner, runnerUp, priority)}</td>
      </tr>`;
    });

    html += `</tbody></table></div>`;
  }

  // Summary bar
  const fiberLabel = `‚â•${CC.highFiber}g ${CC.fiberSpelling.toLowerCase()}`;
  const proteinLabel = CC.highProtein.mode === 'energyPct'
    ? `‚â•${CC.highProtein.pct}% energy protein`
    : `‚â•${CC.highProtein.g}g protein`;
  const constraintLabel = [mustFiber && fiberLabel, mustProtein && proteinLabel]
    .filter(Boolean).join(' + ') || 'none';

  const summaryHtml = `
    <div class="summary-grid" style="margin-bottom:28px;">
      <div class="summary-card"><div class="label">Country</div><div class="value">${document.getElementById('country-select').value}</div></div>
      <div class="summary-card"><div class="label">Q1 Trim</div><div class="value">${userTrimName.replace(' Beef Trim','')}</div></div>
      <div class="summary-card"><div class="label">Priorities √ó Formats</div><div class="value">${priorities.length} √ó ${formats.length}</div></div>
      <div class="summary-card"><div class="label">Constraints</div><div class="value" style="font-size:13px;padding-top:4px">${constraintLabel}</div></div>
    </div>`;

  document.getElementById('output').innerHTML = summaryHtml + html;
}

// Auto-run on load
window.addEventListener('DOMContentLoaded', () => { runValidator(); });
</script>
</body>
</html>
